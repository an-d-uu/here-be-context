# skill-trees ğŸŒ³

Skill trees define core mechanics.

They represent repeatable capabilities that improve the modelâ€™s performance across many situations, rather than solving a single problem. Each tree focuses on a specific dimension of interactionâ€”how intent is read, how tone is managed, how context is retained, and how failures are handled.

These are not scripts.  
They are underlying skills.

---

## ğŸ§  What Skill Trees Are

A skill tree is a collection of patterns, instructions, and constraints that teach the model *how to think* in a particular domain.

They are designed to:

- generalize across projects and prompts
- stack without tightly coupling
- improve reliability rather than creativity
- fail in predictable ways

Skill trees are meant to be revisited, refined, and leveled up over time.

---

## ğŸ—‚ï¸ Tree Breakdown

Each subtree represents a different stat category:

- **perception/**  
  Detecting user intent, ambiguity, and subtext before responding.

- **speech/**  
  Managing tone, formality, and emotional alignment in outputs.

- **intelligence/**  
  Structuring, layering, and preserving context across interactions.

- **crafting/**  
  Creating prompts and instructions that are reusable and resilient.

- **hacking/**  
  Handling edge cases, failure modes, and adversarial or unexpected inputs.

No single tree is sufficient on its own.  
Most real interactions require cross-tree checks.

---

## ğŸ¯ How to Use Skill Trees

Skill trees are best treated as:

- background context
- reusable instruction fragments
- conceptual tools for diagnosing failures

You donâ€™t â€œrunâ€ a skill tree.  
You benefit from having it trained.

---

## âš”ï¸ Common Mistakes

- Treating a skill tree like a one-off prompt
- Over-leveling one tree while neglecting others
- Assuming success in isolation guarantees success in combination

Balanced builds outperform min-maxed ones.

---

Skill trees donâ€™t complete quests for you.  
They determine whether you survive them.
