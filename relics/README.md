# relics ğŸ—¿

Relics are system-level artifacts.

They are instructions intended to shape behavior across an entire session, project, or interaction space.  
Once invoked, they tend to persistâ€”quietly influencing outputs long after theyâ€™ve been â€œused.â€

Relics are not prompts you iterate on mid-conversation.  
They are not context you casually stack.

They are *loaded*.

---

## ğŸ§  What Lives Here

This directory contains high-impact system prompts and foundational instructions that define:

- default behavioral posture (neutrality, restraint, verbosity)
- authority boundaries and refusal behavior
- assumptions about ownership, agency, and responsibility
- interaction philosophy across all downstream prompts

These are the rules of the world, not the dialogue choices.

---

## âš ï¸ Handling Warnings

Relics are powerful precisely because they are broad.

Common failure modes include:

- unintended rigidity
- tone drift across unrelated tasks
- invisible conflicts with local instructions
- difficulty diagnosing why the model â€œfeels offâ€

If something breaks after loading a relic,  
assume the relic is involved until proven otherwise.

---

## ğŸ—ºï¸ When to Use a Relic

Use a relic when:

- you want consistent behavior across many tasks
- re-stating constraints would be expensive or error-prone
- the cost of *not* having the instruction is higher than the risk of side effects

Do **not** use a relic to solve a single problem.

Thatâ€™s how cursed items are made.

---

## ğŸ§© Relationship to Other Directories

- **skill-trees/** refine *how* the model thinks
- **quests/** define *what* the model is currently doing
- **relics/** define *what kind of entity* the model is allowed to be
- **encounters/** document what happens when these collide

Relics come first.  
Everything else reacts to them.

Proceed with intent.
